# DL_project-bku_project-

# 뉴럴 스타일 트랜스퍼 (🌆✖️🌉🔜🌃)
## 개요
뉴럴 스타일 트랜스퍼는 타깃 이미지의 콘텐츠를 보존하면서 참조 이미지의 스타일을 타깃 이미지에 적용합니다:
뉴럴 스타일 전송(Neural style transfer)은 세 개의 이미지, 즉 콘텐츠 이미지, 스타일 참조 이미지(유명한 화가의 작품 등)와 스타일을 원하는 입력 이미지를 혼합하여 입력 이미지가 콘텐츠 이미지처럼 보이지만 스타일 이미지의 스타일로 "페인팅"되도록 하는 최적화 기법이다.
### 🔷 version
- python 👉 3.7.13
- tensorflow 👉 2.8.0
- keras 👉 2.8.0

## 작동 원리
### 🔷 Neural Style Transfer 프로세스
1. 어떤 이미지의 스타일을 가져온다.<br>
2. 그리고 그 스타일을 다른 이미지에 적용한다.

### 🔷 구체적인 개념
- 신속한 실행 — 운영을 즉시 평가하는 TensorFlow의 필수 프로그래밍 환경 사용
- 신속한 실행에 대해 자세히 알아보기
- 실제 작업 보기(많은 튜토리얼이 공동 작업실에서 실행 가능)
- Functional API를 사용하여 모델을 정의합니다. Functional API를 사용하여 필요한 중간 활성화에 액세스할 수 있는 모델의 서브셋을 구축합니다.
- 사전 교육된 모델의 피쳐 맵 활용 — 사전 교육된 모델과 해당 피쳐 맵의 사용 방법 알아보기
- 맞춤형 교육 루프 생성 - 입력 매개 변수와 관련하여 주어진 손실을 최소화하기 위해 최적화 도구를 설정하는 방법을 살펴봅니다.<br>

이러한 과정에서, 우리는 실용적인 경험을 쌓고 다음 개념을 중심으로 직관을 개발할 것입니다.

## 진행 과정
### 🔷 일반적인 단계에 따라 스타일 전송을 수행합니다.
1. 데이터 시각화
2. 기본 데이터 사전 처리/준비
3. 손실 함수 설정
4. 모델 만들기
5. 손실 기능에 최적화

## loss
### 🔷 뉴럴 스타일 트랜스퍼는 다음과 같이 작동합니다.
- Style Image가 Conv 레이어들을 거쳐 나온 Feature Map의 각 채널별 특징의 상관관계 값을 Style Loss값으로 정의
- Content Image가 Conv4 레이어를 거쳐 나온 Feature Map의 차이를 Content Loss 값으로 정의
- 위 두 Loss값이 작아지도록 학습하여 New Image 만들어간다.

## Model
### 🔷 모델 구축
VGG19를 로드하고 입력 텐서를 모델에 공급한다. 이를 통해 콘텐츠, 스타일 및 생성된 이미지의 피쳐 맵(그리고 그 이후에 콘텐츠 및 스타일 표현)을 추출할 수 있습니다. 
우리는 책에서 사용한 대로 VGG19를 사용하였습니다. 또한 VGG19는 (ResNet, Inception 등과 비교하여) 비교적 단순한 모델이기 때문에 기능 맵은 실제로 스타일 전송에 더 잘 작동한다. 
스타일 및 콘텐츠 기능 맵에 해당하는 중간 레이어에 액세스하기 위해 해당 출력을 얻고 Keras Functional API를 사용하여 원하는 출력 활성화로 모델을 정의한다. 
Functional API를 통해 모델을 정의하면 입력과 출력을 정의할 수 있습니다.<br>
#### model = Model(inputs, outputs)

### 🔷 컨텐츠 및 스타일 표현 정의
이미지의 내용과 스타일 표현을 모두 얻기 위해 모델 내의 몇 가지 중간 계층을 살펴볼 것이다. 
중간 계층은 깊이 들어갈수록 점점 더 높은 순서가 되는 피쳐 맵을 나타냅니다. 
이 경우 사전 훈련된 이미지 분류 네트워크인 네트워크 아키텍처 VGG19를 사용하고 있다. 
이러한 중간 계층은 이미지에서 콘텐츠와 스타일의 표현을 정의하는 데 필요하다. 
입력 이미지의 경우 이러한 중간 계층에서 해당 스타일 및 콘텐츠 대상 표현을 일치시키도록 시도합니다.

## 주요 내용
### 🔷 다룬 내용
우리는 손실을 최소화하기 위해 몇 가지 다른 손실 함수를 구축하고 역전파를 사용하여 입력 이미지를 변환했다. 
이를 위해 사전 훈련된 모델에 로드하고 학습된 피쳐 맵을 사용하여 이미지의 내용과 스타일 표현을 설명해야 했다. 
우리의 주요 손실 함수는 주로 이러한 다른 표현들의 관점에서 거리를 계산하는 것입니다. 
이를 맞춤형 모델과 신속한 실행으로 구현하였고 Functional API를 사용하여 맞춤형 모델을 구축했습니다.<br>
신속한 실행을 통해 자연스러운 파이썬 제어 흐름을 사용하여 텐서로 동적으로 작업할 수 있습니다. 
우리는 텐서를 직접 조작하여 디버깅과 텐서 작업을 쉽게 할 수 있습니다. 
우리는 tf.gradient를 사용하여 옵티마이저 업데이트 규칙을 적용하여 이미지를 반복적으로 업데이트했다. 최적기는 입력 이미지와 관련하여 주어진 손실을 최소화했다.

### 🔷 타겟 이미지
![target](https://user-images.githubusercontent.com/63196575/171191065-a6a5e3bc-2851-430d-9613-4b8bcbae5d0a.jpg)
### 🔷 스타일 이미지
![Picasso](https://user-images.githubusercontent.com/63196575/171192356-e477279c-347c-48b4-8848-fa8b91681f15.jpg)
### 🔷 생성 이미지
![style_transfer_result_at_iteration_19](https://user-images.githubusercontent.com/63196575/171191099-5baa26a9-1439-481c-871c-0153044a1a5d.png)

